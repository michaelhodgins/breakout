// Generated by CoffeeScript 1.7.1

/*
Game is a class for coordinating the drawing surface, game entities and game loop.
 */
var Game;

Game = (function() {

  /*
  Construct the game with the given drawing surface. If fps is given, it is only used if the
  browser doesn't support a native FPS system.
   */
  function Game(canvas, fps, colours) {
    this.canvas = canvas;
    this.fps = fps != null ? fps : 60;
    this.colours = colours != null ? colours : null;
    this.context = this.canvas.getContext('2d');
    this.width = this.canvas.width;
    this.height = this.canvas.height;
    this.desiredStep = 1000 / this.fps;
    this.debug = false;
    this.paused = false;
    this.pausedLoops = 0;
    this.runningLoops = 0;
    this.keyPressed = {};
    $(this.canvas).on('keydown keyup', (function(_this) {
      return function(event) {
        var keyName;
        keyName = Game.keys[event.which];
        if (keyName) {
          _this.keyPressed[keyName] = event.type === 'keydown';
          return event.preventDefault();
        }
      };
    })(this));
    this.setup();
  }


  /*
  Add an Entity object to the game. If name is given, the entity is associated with that name, thad this can be used
  later to retrieve the entity by calling getNamedEntity().
   */

  Game.prototype.addEntity = function(entity, name) {
    if (name == null) {
      name = false;
    }
    this.entities.push(entity);
    if (name) {
      this.namedEntities[name] = entity;
    }
    if (name === "scoreBoard") {
      return this.playArea.y += entity.height;
    }
  };


  /*
  Return the entity associated with the given name.
   */

  Game.prototype.getNamedEntity = function(name) {
    return this.namedEntities[name];
  };


  /*
  Call to indicate that a life has been lost.
   */

  Game.prototype.lifeLost = function() {
    this.lives--;
    if (this.lives > 0) {
      return this.getNamedEntity("ball").reset();
    } else {
      return this.gameOver();
    }
  };


  /*
  Call to indicate that a the given block has been hit. This is used for scoring.
   */

  Game.prototype.blockHit = function(block) {
    if (block.hits < block.hitPoints) {
      return this.score++;
    } else {
      return this.score += 5;
    }
  };


  /*
  Render the game over message.
   */

  Game.prototype.gameOver = function() {
    this.getNamedEntity("scoreBoard").draw(this.context);
    return this.messageBox("Game Over!", "Press S to play again.");
  };


  /*
  Set up the game's entities, score, lives and play area.
   */

  Game.prototype.setup = function() {
    this.lives = 3;
    this.score = 0;
    this.entities = [];
    this.namedEntities = {};
    this.playArea = {
      x: 0,
      y: 0,
      height: this.height,
      width: this.width
    };
    this.addEntity(new Background(this), "background");
    this.addEntity(new ScoreBoard(this), "scoreBoard");
    this.addEntity(BlockMap.getBlockMap(this), "blockMap");
    this.addEntity(new Ball(this), "ball");
    return this.addEntity(new Paddle(this), "paddle");
  };


  /*
  Call to pause the game.
   */

  Game.prototype.pause = function() {
    if (this.runningLoops > 10) {
      this.runningLoops = 0;
      this.paused = true;
      if (this.paused) {
        return this.messageBox("Paused", "Press P to continue.");
      }
    }
  };


  /*
  Call to unpause the game.
   */

  Game.prototype.unpause = function() {
    if (this.pausedLoops > 10) {
      this.pausedLoops = 0;
      return this.paused = false;
    }
  };

  Game.prototype.nextLevel = function() {
    console.log("nextLevel");
    this.getNamedEntity("blockMap").reset();
    return this.getNamedEntity("ball").reset();
  };


  /*
  Render a message box.
   */

  Game.prototype.messageBox = function(title, text) {
    this.context.beginPath();
    this.context.rect(this.width / 5, this.height / 3, this.width / 5 * 3, this.height / 3);
    this.context.fillStyle = this.colours.getColour("messageBoxBackground");
    this.context.fill();
    this.context.fillStyle = this.colours.getColour("messageBoxForeground");
    this.context.font = '32px monospace';
    this.context.fillText(title, this.width / 4, this.height / 2 - 20);
    this.context.font = '12px monospace';
    return this.context.fillText(text, this.width / 4, this.height / 2 + 30);
  };


  /*
  Called to start the game loop
   */

  Game.prototype.start = function() {
    this.recordUpdate();
    return this.frame((function(_this) {
      return function() {
        return _this.loop();
      };
    })(this));
  };


  /*
  Sets up the mechanism for repeatedly updating and drawing the game.
   */

  Game.prototype.frame = function(callFrame) {
    var interval;
    if (window.requestAnimationFrame) {
      return window.requestAnimationFrame((function(_this) {
        return function() {
          callFrame();
          return _this.frame(callFrame);
        };
      })(this));
    } else {
      interval = 1000 / this.fps;
      return setInterval(function() {
        return callFrame();
      }, interval);
    }
  };


  /*
  Execute one update and drawing loop.
   */

  Game.prototype.loop = function() {
    var startTime, steps, timePassed;
    if (this.lives < 1 && this.keyPressed.S) {
      this.setup();
    }
    if (this.lives > 0) {
      if (this.keyPressed.P) {
        if (!this.paused) {
          this.pause();
        } else {
          this.unpause();
        }
      }
      if (this.paused) {
        this.pausedLoops++;
      } else {
        this.runningLoops++;
      }
      if (this.getNamedEntity("blockMap").blocksRemaining() === 0) {
        this.nextLevel();
      }
    }
    startTime = new Date().getTime();
    timePassed = startTime - this.lastUpdate;
    steps = this.desiredStep / timePassed;
    this.update(steps);
    this.draw();
    return this.recordUpdate();
  };


  /*
  Update all the entities once.
   */

  Game.prototype.update = function(steps) {
    var entity, _i, _len, _ref;
    if (this.lives > 0 && !this.paused) {
      _ref = this.entities;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        entity = _ref[_i];
        if (entity.update) {
          entity.update(steps);
        }
      }
    }
    if (this.debug) {
      return $("#vector").html("Ball Vector: " + (this.ball.vector.toFixed(1)) + "Â°");
    }
  };


  /*
  Draw each entity.
   */

  Game.prototype.draw = function() {
    var entity, _i, _len, _ref, _results;
    if (this.lives > 0 && !this.paused) {
      this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
      _ref = this.entities;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        entity = _ref[_i];
        if (entity.draw) {
          _results.push(entity.draw(this.context));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    }
  };


  /*
  Call to record when an update cycle was completed
   */

  Game.prototype.recordUpdate = function() {
    return this.lastUpdate = new Date().getTime();
  };


  /*
  Constants for some keys we're interesting in
   */

  Game.keys = {
    32: "space",
    37: "left",
    38: "up",
    39: "right",
    40: "down",
    80: "P",
    83: "S"
  };

  return Game;

})();
