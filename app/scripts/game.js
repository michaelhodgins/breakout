// Generated by CoffeeScript 1.7.1

/*
Game is a class for coordinating the drawing surface, game entities and game loop.
 */
var Game;

Game = (function() {

  /*
  Construct the game with the given drawing surface. If fps is given, it is only used if the
  browser doesn't support a native FPS system.
   */
  function Game(canvas, fps, colours) {
    this.canvas = canvas;
    this.fps = fps != null ? fps : 60;
    this.colours = colours != null ? colours : null;
    this.context = this.canvas.getContext('2d');
    this.width = this.canvas.width;
    this.height = this.canvas.height;
    this.playArea = {
      x: 0,
      y: 0,
      height: this.height,
      width: this.width
    };
    this.lives = 3;
    this.score = 0;
    this.entities = [];
    this.namedEntities = {};
    this.desiredStep = 1000 / this.fps;
    this.debug = false;
    this.keyPressed = {};
    $(this.canvas).on('keydown keyup', (function(_this) {
      return function(event) {
        var keyName;
        keyName = Game.keys[event.which];
        if (keyName) {
          _this.keyPressed[keyName] = event.type === 'keydown';
          return event.preventDefault();
        }
      };
    })(this));
  }

  Game.prototype.addEntity = function(entity, name) {
    if (name == null) {
      name = false;
    }
    this.entities.push(entity);
    if (name) {
      this.namedEntities[name] = entity;
    }
    if (name === "scoreBoard") {
      return this.playArea.y += entity.height;
    }
  };

  Game.prototype.getNamedEntity = function(name) {
    return this.namedEntities[name];
  };


  /*
  Called to start the game loop
   */

  Game.prototype.start = function() {
    this.recordUpdate();
    return this.frame((function(_this) {
      return function() {
        return _this.loop();
      };
    })(this));
  };


  /*
  Sets up the mechanism for repeatedly updating and drawing the game.
   */

  Game.prototype.frame = function(callFrame) {
    var interval;
    if (window.requestAnimationFrame) {
      return window.requestAnimationFrame((function(_this) {
        return function() {
          callFrame();
          return _this.frame(callFrame);
        };
      })(this));
    } else {
      interval = 1000 / this.fps;
      return setInterval(function() {
        return callFrame();
      }, interval);
    }
  };


  /*
  Execute one update and drawing loop.
   */

  Game.prototype.loop = function() {
    var startTime, steps, timePassed;
    startTime = new Date().getTime();
    timePassed = startTime - this.lastUpdate;
    steps = this.desiredStep / timePassed;
    this.update(steps);
    this.draw();
    return this.recordUpdate();
  };


  /*
  Update all the entities once.
   */

  Game.prototype.update = function(steps) {
    var entity, _i, _len, _ref;
    _ref = this.entities;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      entity = _ref[_i];
      if (entity.update) {
        entity.update(steps);
      }
    }
    if (this.debug) {
      return $("#vector").html("Ball Vector: " + (this.ball.vector.toFixed(1)) + "Â°");
    }
  };


  /*
  Draw each entity.
   */

  Game.prototype.draw = function() {
    var entity, _i, _len, _ref, _results;
    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    _ref = this.entities;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      entity = _ref[_i];
      if (entity.draw) {
        _results.push(entity.draw(this.context));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };


  /*
  Call to record when an update cycle was completed
   */

  Game.prototype.recordUpdate = function() {
    return this.lastUpdate = new Date().getTime();
  };


  /*
  Constants for some keys we're interesting in
   */

  Game.keys = {
    32: 'space',
    37: 'left',
    38: 'up',
    39: 'right',
    40: 'down'
  };

  return Game;

})();
